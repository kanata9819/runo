# GUI ライブラリ基礎知識

## 1. GUI ライブラリの責務

GUI ライブラリは最低限、次の責務を持ちます。

1. ウィンドウ・イベントループ管理
2. 入力の正規化（マウス、キーボード、IME）
3. UI 要素の状態管理
4. レイアウト計算
5. 描画コマンド生成
6. GPU/OS への表示反映

## 2. 即時モードと保持モード

1. 即時モード（Immediate Mode）
   毎フレーム UI を再記述する。実装が単純でデバッグしやすい。
2. 保持モード（Retained Mode）
   UI ツリーやノードを保持し、差分更新して描画する。大規模化に強い。

多くの実用ライブラリは、どちらか一方ではなくハイブリッドです。

## 3. UI 状態の層分け

状態は混ぜると破綻しやすいので、層を分けます。

1. アプリ状態
   ドメイン固有の状態（例: `is_logged_in`, `selected_file`）
2. ウィジェット状態
   hover, focus, pressed, scroll など UI インタラクション状態
3. レンダリング状態
   フォントキャッシュ、テクスチャ、GPU リソースなど

## 4. UI ツリーと ID

保持型で最重要なのが ID 管理です。

1. ID が安定している
   フレームを跨いでも同一ノードと判定できる
2. ID が一意である
   衝突するとイベントが別ウィジェットに飛ぶ
3. ID 生成規則が再現可能
   自動生成なら親ノードと順序に依存しすぎない設計にする

## 5. フレームの典型フェーズ

1. 入力収集
2. 状態更新
3. レイアウト
4. 描画コマンド生成
5. GPU 提出
6. 後処理（入力リセット、一時バッファ解放）

## 6. 最初に押さえる設計原則

1. 責務の分離
   入力、レイアウト、描画、リソース管理を分離
2. 決定性
   同じ入力なら同じ結果になる
3. 参照透過に近づける
   副作用を境界に閉じ込める
4. 可観測性
   ログ、可視化、トレースを最初から入れる

## 7. よくある失敗

1. 入力処理と描画処理を密結合する
2. ID を軽視してクリック判定が壊れる
3. レイアウトと描画の責務を混ぜる
4. キャッシュ無効化条件が曖昧でバグる

